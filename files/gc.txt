1. Запуск программы StartUI со следующим сборщиком мусора:
[0.013s][info][gc     ] Using Serial

2. Профилирование выполнено с помощью графического интерфейса jconsole (скриншоты приложены)
Время 21:31. Запуск jconsole. Eden space линейно растет.
Время 21:34. Добавляем 555тыс. заявок. Большая часть объектов сразу попадали в кучу Old (Tenured Gen). Небольшая часть попадает в Survivor Space.
Время 21:37. Происходит автоматическая очистка Survivor Space и Eden (при достижении 33 Мб) с последующим переносом объектов в Old space. Eden space продолжает монотонно расти.
Время 21:40. Вызов команды "Показать все объекты". Добавлены новые объекты в Old и Survivor space.
Время 21:44. Происходит автоматическая очистка памяти
Время 21:52. Выполнена сборка мусора в ручном режиме Perform GC. Eden и Survivor Space очищены. Old Space без изменений
Время 21:53. Вызов команды "Удаление всех заявок". Новые объекты попадают в Eden, остальные Space Old и Survivor без изменений
Время 21:56. Выполнена сборка мусора в ручном режиме Perform GC. Происход очистка Old и Eden
Время 22:00. Добавление 20 млн заявок. Exception in thread "main" java.lang.OutOfMemoryError: Java heap space

2. Профилирование с помощью jmap
Выполнена команда jmap -histo 10270. Отображен список созданных объектов, сколько они занимают паммяти и названия классов
Добавлено 555 тыс заявок.
Повтороно выполняем jmap -histo 10270. Созданы для каждого класса по 555 тыс. объектов Item, LocalTime, LocalDate, LocalDateTime, String и B (последнеий класс не понятен).
После удаления всех объектов память не очищена. Объекты до сих пор в Heap

3. Профилирование с помощью команды jstat -gc <pid> 1s 10
После запуска программы и вызова различных команды в StartUI выполнены промежуточные запуски команды jstat, по результатам которых получена информация о состоянии памяти Old, Eden и Survivor

